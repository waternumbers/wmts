#' Function to generate a single tile
#' @param rst a SpatRaster object to generate tiles from
#' @param pal a palette of breaks and colours as generated by \code{genPalette}
#' @param Z zoom level
#' @param X value of the tile
#' @param Y value of the tile
#' @param w width of tiles in pixels
#' @param h height of tiles in pixels
#' @param method method of interpolation (not used)
#'
#' @return a raw png vector
#' 
#' @details This uses the terra library to project \code{rst} onto the correct tile area. Tiles are then generated by cutting into the classes in pal.
#' 
#' @export
singleTile <- function(rst,pal,Z,X,Y,w=512,h=w,method=c("bilinear","ngb")){
    method <- match.arg(method)

    if(!("SpatRaster" %in% class(rst))){
        stop("rst is not a SpatRaster object")
    }

    ## get wkt string for the desired projection
    wkt <- terra::crs(terra::rast(crs="EPSG:3857"))
    resample_flag <- terra::crs(rst)==wkt

    ## unpack the colour palette
    pal <- pal[order(pal$brk),] ## make sure ordered
    brk <- pal$brk
    pal <- t(grDevices::col2rgb(pal$col,alpha=TRUE)) / 255
    step <- (20037508*2)/(2^Z)
    p <- terra::rast(nrows=w, ncols=h, nlyrs=1,
                     xmin=-20037508 + X*step,
                     xmax=-20037508 + (X+1)*step,
                     ymin=20037508 - (Y+1)*step,
                     ymax=20037508 - Y*step,
                     crs = "EPSG:3857"
                     )
    if( resample_flag ){
        pp <- terra::resample(rst,p)
    }else{                   
        pp <- terra::project(rst,p)
    }
    
    idx <- as.vector( terra::as.matrix(pp,wide=TRUE) )
    out <- NULL
    if( any(is.finite(idx)) ){
        idx <- cut(idx,brk)
        tmp <- array(pal[idx,],c(h,w,4))
        out <- png::writePNG(tmp) #,file.path(outdir,Z,X,paste0(Y,".png")))
    }
    return(out)
}
